\section{Literature review}\label{sec:literature-review}

Ornaments fall within the wider topic of generic programming.
In particular, all the current formalizations of ornaments work on
some generic representation of data types.
We will give an overview of the current state of generic programming,
making use of the strengths of dependent types in particular.

\subsection{Universe of finite types}

Finite types can be constructed using four operations: $0$, $1$, $+$ and
$*$ \cite{altenkirch06}.
A pair of two booleans for instance is $(1 + 1) * (1 + 1)$.
We can express this in Agda with the \AD{Desc} data type.

\InsertCodeN{finite-desc}

We write an interpretation function which converts descriptions to a
type of which the inhabitants correspond with the inhabitants of the
described type.

\InsertCodeN{finite-interpretation}

If we restrict ourselves to only build sums of products, the described
types correspond directly with data types in, for instance, Agda.

\subsection{Universe of context-free types}

We can extend our definition of finite types to context-free types by
adding a $μ$ operator to construct inductive types.
For instance, $Nat$ can be expressed as $Nat = μX. 1 + x$ and List as $List
A = μX. 1 + A × X$.
Context-free types also allow multiple variable bindings, rose trees
can be expressed as $RT A = μX. List (A × X) = μX. μY. 1 + (A × X) × Y$.

To represent these types we have to be able to bind and refer to
variables.
Following Altenkirch et al \cite{altenkirch06}), we might expand the
definition of \AD{Desc} in listing \ref{code:finite-desc} to represent
these operations.
We introduce a \AD{ℕ} index to indicate the number of free variables.

\InsertCode{contextfree-naive-desc}

Now we can describe all the context-free types.
However, an interpretation function \AF{⟦\_⟧} is not so
straightforward.
A naive definition of this function will not be accepted by Agda's
termination checker.
Indeed, when we try to interpret \AF{‵nat} = \AI{‵1} \AI{‵+} \AI{`var}
\AY{(}\AF{\#} \AN{0}\AY{)} we get an expanding term \AF{⟦} \AF{‵nat}
\AF{⟧} = \AR{⊤} \AD{⊎} \AF{⟦} \AF{‵nat} \AF{⟧} = ..

\subsubsection{Single fixpoint}\label{sec:cft-single}

A well known solution to this non-termination is to introduce the
induction later using a fix point data type (source?).
We will start out with single fixpoints.
With single fixpoints we can only describe context free types with one
$μ$, and it must be on the outside of the type (source?).
In other words, we can only induce on one variable.

With this method we get rid of the explicit \AI{μ} constructor.
In the interpretation of the descriptions we assume an implicit $μ$ on
the outside.
The interpretation function \AF{⟦\_⟧} is now of type \AD{Desc} \AY{→}
\AD{Set} \AY{→} \AD{Set}, so it takes a \AD{Desc} and gives us a
functor on \AD{Set}.
Taking the fixpoint of the \AD{Set}-functor gives us a \AD{Set} we can
use.

\InsertCode{contextfree-one-base}

\begin{shaded}
  A general fixpoint data type can not be written in Agda, but if we
  specialize it to Desc that's fine.
\end{shaded}

\subsubsection{Multiple fixpoints}

Real context-free types can have multiple variable bindings.
Take for instance $NatList = μX. 1 + (μY. 1 + Y) × Y$.
These are hard (impossible?) to define, since we would need something
like internal fixpoints.

Luckily, we can always transform a type with internal variable
bindings into multiple types which do not have internal variable
bindings (source?).
$NatList$ can be split into two types $Nat = μY. 1 + Y$ and $NatList =
μX. 1 + Nat × X$.

If we can express mutually recursive context-free types without internal
variable bindings, we can express all context-free types.

Mutually recursive types can be described with indices. As in
Multirec, and generalized in gentle art of levitation.

\subsection{Containers}

Discuss the semantic approach with containers/signatures.


\subsection{Encoding dependent types}

One of things we can express using dependent types is a
\emph{dependent pair}.
We can change the constructor \AI{\_‵*\_} to allow the description of
the type on the right side of a pair to depend on the value on the
left side.
We can see that interpretation indeed uses the \AR{Σ} for dependent pairs.

\InsertCode{finite-dep-*-desc}
\InsertCode{finite-dep-*-interpretation}

\begin{shaded}
  I'm not quite sure if this is the right way.
  Need to find some papers about this..
  Induction-Recursion seems to be relevant.
\end{shaded}


