
\section{Project Description}\label{sec:project-description}

Using indexed data types and dependent types it is possible to encode
logic in algebraic data types to enforce invariants.
Encoding invariants in data types allows us to write correct-by-construction
software.
However, it makes code reuse very hard.
Functions which work on one data type do not work on a similar data
type with added invariants.

Algebraic ornaments capture the relationship between two data types
with the same recursive structure.
Ornaments can be used to transform a functions which work on the first
data type to functions which work on the second.
For instance to transform addition on natural numbers to append on lists.

This topic has been explored and formalised in Agda.
These implementations require you to describe your data types within a
universe of descriptions.
The descriptions can be interpreted as a data type, but this approach is not ideal for programming.

In this project we will work towards a more practical way to use
ornaments in Agda.
We want to be able to define data types as usual and define ornaments
on these data types.
Ornamenting a data type should result in a newly defined data type.
Additionally, it should be possible to transform functions using these
ornaments.
For this we need to be able to quote and unquote both data type and function definitions, for which we might have to modify the Agda compiler.

Aims:

\begin{itemize}
\item Research current implementations
\item Usable implementation of ornaments in Agda
\item Study dependent type theory, data types, generic programming,
algebraic ornaments
\end{itemize}

\section{Generic programming in Agda}\label{sec:generic-programming-in-agda}


\subsection{Finite types}

Finite types can be constructed using four operations: $0$, $1$, $+$ and
$*$ \cite{altenkirch06}.
A pair of two booleans for instance is $(1 + 1) * (1 + 1)$.
We can express this in Agda with the \AD{Desc} data type.

\InsertCodeN{finite-desc}

We write an interpretation function which converts descriptions to a
type of which the inhabitants correspond with the inhabitants of the
described type.

\InsertCodeN{finite-interpretation}

If we restrict ourselves to only build sums of products, the described
types correspond directly with data types in, for instance, Agda.

\subsubsection{Dependent types}

One of things we can express using dependent types is a
\emph{dependent pair}.
We can change the constructor \AI{\_‵*\_} to allow the description of
the type on the right side of a pair to depend on the value on the
left side.
We can see that interpretation indeed uses the \AR{Σ} for dependent pairs.

\InsertCode{finite-dep-*-desc}
\InsertCode{finite-dep-*-interpretation}

\begin{shaded}
  I'm not quite sure if this is the right way.
  Need to find some papers about this..
\end{shaded}

\subsection{Context-free types}

We can extend our definition of finite types to context-free types by
adding a $μ$ operator to construct inductive types.
For instance, $Nat$ can be expressed as $Nat = μX. 1 + x$ and List as $List
A = μX. 1 + A × X$.
Context-free types also allow multiple variable bindings, rose trees
can be expressed as $RT A = μX. List (A × X) = μX. μY. 1 + (A × X) × Y$.

To represent these types we have to be able to bind and refer to
variables.
Following Altenkirch et al \cite{altenkirch06}), we might expand the
definition of \AD{Desc} in listing \ref{code:finite-desc} to represent
these operations.
We introduce a \AD{ℕ} index to indicate the number of free variables.

\InsertCode{contextfree-naive-desc}

Now we can describe all the context-free types.
However, an interpretation function \AF{⟦\_⟧} is not so
straightforward.
A naive definition of this function will not be accepted by Agda's
termination checker.
Indeed, when we try to interpret \AF{‵nat} = \AI{‵1} \AI{‵+} \AI{`var}
\AY{(}\AF{\#} \AN{0}\AY{)} we get an expanding term \AF{⟦} \AF{‵nat}
\AF{⟧} = \AR{⊤} \AD{⊎} \AF{⟦} \AF{‵nat} \AF{⟧} = ..

\subsubsection{Single fixpoint}

A well known solution to this non-termination is to introduce the
induction later using a fix point data type (source?).
We will start out with single fixpoints.
With single fixpoints we can only describe context free types with one
$μ$, and it must be on the outside of the type (source?).
In other words, we can only induce on one variable.

With this method we get rid of the explicit \AI{μ} constructor.
In the interpretation of the descriptions we assume an implicit $μ$ on
the outside.
The interpretation function \AF{⟦\_⟧} is now of type \AD{Desc} \AY{→}
\AD{Set} \AY{→} \AD{Set}, so it takes a \AD{Desc} and gives us a
functor on \AD{Set}.
Taking the fixpoint of the \AD{Set}-functor gives us a \AD{Set} we can
use.

\InsertCode{contextfree-one-base}

\begin{shaded}
  A general fixpoint data type can not be written in Agda, but if we
  specialize it to Desc that's fine.
\end{shaded}

\subsubsection{Multiple fixpoints}

Real context-free types can have multiple variable bindings.
Take for instance $NatList = μX. 1 + (μY. 1 + Y) × Y$.
These are hard (impossible?) to define, since we would need something
like internal fixpoints.

Luckily, we can always transform a type with internal variable
bindings into multiple types which do not have internal variable
bindings (source?).
$NatList$ can be split into two types $Nat = μY. 1 + Y$ and $NatList =
μX. 1 + Nat × X$.

If we can express mutually recursive context-free types without internal
variable bindings, we can express all context-free types.

Mutually recursive types can be described with indices. As in
Multirec, and generalized in gentle art of levitation.





\subsection{Signatures}


\section{Quoting library}\label{sec:quoting-library}




% Hoi even testen:

% \InsertCode{example1}

% En inline dingen zoals \InsertCodeInline{example2} werken ook.
